[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "My Blog",
    "section": "",
    "text": "Mortality to HPAI and Trees\n\n\n\nanalysis\n\n\nphylogenetics\n\n\n\nA Short R document detailing a analysis on HPAI and mortality from a phylogenetic standpoint\n\n\n\nJonathan Dain\n\n\nApr 30, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBoston City Nature Challenge\n\n\n\nBirding\n\n\n\nMy first blog post to this new site, detailing the events of the Boston City Nature Challenge\n\n\n\nJonathan Dain\n\n\nApr 29, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to The Duck Tapes",
    "section": "",
    "text": "Welcome, I am so glad you are here!\n\n\n\nA Great Black-Back Gull in an Island Sunrise\n\n\nPlease feel free to take a look around. Blog posts about my research can be found under the “My Blog” tab. Check out the “About Me” page to get to know me. “Photos” has a collection of fun pictures from the beautiful places that “virus-hunting” has taken me. Finally, the “Extras” page has a collection of links and posts from other areas of my life some of which are non-research related.\nHope to see you around sometime and if you are in the Massachusets area, I’d love to grab a coffee."
  },
  {
    "objectID": "Blog_Posts/2024-04-29/2024-04-29.html",
    "href": "Blog_Posts/2024-04-29/2024-04-29.html",
    "title": "Boston City Nature Challenge",
    "section": "",
    "text": "The City Nature Challenge is a fun worldwide collaborative bioblitz with cities across the world to observe the most species (April 26 - April 29) and then ID them (April 30 - May 6)! We’ll be documenting urban biodiversity within the I-495 corridor, out to Stellwagen Bank, including Cape Cod and islands. It’s simple, it’s fun, and it contributes to scientific data helping to better understand our world and our non-human neighbors!\n.\nCopied from -&gt; https://www.bostoncnc.org/\n\nCitizen science is an amazing movement that is becoming increasingly more and more impactful as the years go by. Just look at the number of publications with the keyword “citizen science” over the years.\n\nYet how do we actually define citizen science?\nCitizen science is a very broad term that can have many nuances depending on who you talk with. However a very simple definition that I am quite fond of is as follows:\n\n“Citizen science broadly refers to the active engagement of the general public in scientific research tasks. Citizen science is a growing practice in which scientists and citizens collaborate to produce new knowledge for science and society.” (Vohland et al. 2021)\n\nI like this definition for two reasons:\n\nIt calls out the fact that there is a need to engage the public in research. Putting the task of “engaging” back on the scientist. In other words scientists need to be mindful of how they are engaging the community.\nIt speaks to the fact that there is a collaboration where both parties gain something, rather than a just a single researcher gaining new data for their project.\n\nSo now that we have a working definition of citizen science lets talk about the Boston City Nature Challenge! This past weekend there was a concentrated effort by scientists and the public alike to go out and catalog the biodiversity of the greater Boston area over the course of three days. As I am writing this there are currently 11,276 observations, representing 1,589 species (141 of which are birds in case you were curious). All of this was contributed by 1,227 observers. When you put this in context that this was just over the course of four days that is an amazing number of species seen. Especially since alot of these are not “professional” researchers going out to sample their focal taxa!\nBy the way 23 of those observations were mine :)\nThe best part of this is that you too can participate in something like this through the use of your own cellphone! You don’t need the fanciest piece of camera equipment to go and capture the local diversity. The tools to aid in the understanding of our natural world are in your hands, or at least they can be!\nIt is just the click of a few buttons to get the app here\nYou might be wondering at this point what I actually saw during this event right? Well I had the privilage to work with a group of other students to survey the Harbor Islands here in Boston for birds. We went our early in the morning last Friday in a boat around the islands. Part of our team was interested in the seal population, however I wanted to highlight the amazing avian biodiversity on these islands. In total we saw over 16 species of birds. Below are some of my photos, I hope that you enjoy them as much as I do.\n\n\n\nA Herring Gull\n\n\n\n\n\nA Common Eider\n\n\n\n\n\nAnother Common Eider\n\n\n\n\n\nAn American Oystercather in Flight\n\n\n\n\n\nSurf Scoters in Flight\n\n\nIf you want to see more pcitures from the Boston City Nature challenge you can view them all here, which is the same link as above.\nIf you want to see more of my photos and citizen science you can see my eBird account and my iNaturalist account for more.\nI hope you have a fantastic day and as always keep your eyes to the sky!\nCheers, Jonathan Dain\n\n\n\n\n\n\n\nReferences:\n\nVohland, Katrin, Anne Land-Zandstra, Luigi Ceccaroni, Rob Lemmens, Josep Perelló, Marisa Ponti, Roeland Samson, and Katherin Wagenknecht, eds. 2021. The Science of Citizen Science. Cham: Springer International Publishing. https://doi.org/10.1007/978-3-030-58278-4."
  },
  {
    "objectID": "Blog_Posts/2024-04-30/2024-04-30.html",
    "href": "Blog_Posts/2024-04-30/2024-04-30.html",
    "title": "Mortality to HPAI and Trees",
    "section": "",
    "text": "A ‘short’ R script by Jonathan Dain.\nGoal: We want to understand the mortality rates in while birds due to HPAI and how it relates to the underlying phylogeny that connects bird species. So let’s dive in.\n\n\n\npacman::p_load(phytools,\n               ggplot2,\n               ggthemes,\n               tidyverse,\n               geiger,\n               knitr,\n               phangorn,\n               rethinking)\n\n\n\n\nOur data comes from multiple sources so I will load each one and give a brief overview of each. To start we need to get our raw data about mortality in wild birds due to HPAI. This data come from the USDA website. It is a collection of observations of HPAI in wild birds. Admittedly this is a very sparse dataset and I know that alot of their observations are oppourtunistic rather than focused searching….but its what we got so lets put it to work.\n\nraw_usda &lt;- read_csv(file = \"data/hpai-wild-birds (1).csv\")\n\nhead(raw_usda) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nState\nCounty\nCollection Date\nDate Detected\nHPAI Strain\nBird Species\nWOAH Classification\nSampling Method\nSubmitting Agency\n\n\n\n\nSouth Carolina\nColleton\n12/30/2021\n01/13/2022\nEA H5N1\nAmerican wigeon\nWild bird\nHunter harvest\nNWDP\n\n\nSouth Carolina\nColleton\n12/30/2021\n01/13/2022\nEA H5N1\nBlue-winged teal\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n12/30/2021\n01/12/2022\nEA H5N1\nNorthern shoveler\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5N1\nAmerican wigeon\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5\nGadwall\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5\nGadwall\nWild bird\nHunter harvest\nNWDP\n\n\n\n\n\nOk the other dataset that we will need is a species lookup file that I have made for replacing common names with species names. It takes as input a common name - often poorly spelled - and replaces it with the correctly spelled latin name. It can also add in some other useful bits which we will look at later.\n\nSpecies_Lookup &lt;- readRDS(file = \"/Users/jonathandain/My_Files/My_Code/Species_Lookup_Sheet/Species_Lookup_20240323.rds\")\n\nhead(Species_Lookup) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\nalt.common.name\ntype\nscientific.name\nenlish.name.ebird\norder\nfamily\n\n\n\n\nafrican crowned crane\nOther\nbalearica regulorum\ngray crowned-crane\ngruiformes\ngruidae (cranes)\n\n\namerican black duck\nDabbling duck\nanas rubripes\namerican black duck\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\namerican blue-winged teal\nDabbling duck\nspatula discors\nblue-winged teal\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\namerican coot\nOther\nfulica americana\namerican coot\ngruiformes\nrallidae (rails, gallinules, and coots)\n\n\namerican crow\nOther\ncorvus brachyrhynchos\namerican crow\npasseriformes\ncorvidae (crows, jays, and magpies)\n\n\namerican green-winged teal\nDabbling duck\nanas crecca\ngreen-winged teal\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\n\n\n\nFinally as you might be wondering we need a bird phylogenetic tree! Thankfully the hard work of actually producing a bird tree has been done for us by the lovely people at BirdTree, we just get to reap the benefits.\n\nallbirdtree &lt;- readRDS(file = \"data/allbirdtree.rds\")\n#note this is a massive multiphylo object so it may take a smidge of time to load.\n\nOk now that our data is loaded we can move onto some data wrangling. Which is the second most fun part of any research question.\n\n\n\nOk first we need to do some data wrangling to make this USDA data usable.let’s first deal with the getting a sense of the data and if these birds are alive or dead when sampled. In other words what is the disease phenotype.\n\n### make a copy of the data\nd &lt;- raw_usda |&gt; \n  mutate_all(.funs = tolower) #make the names lowercase\n\n### look at the sampling methods as levels\nlevels(as.factor(x = d$`Sampling Method`)) |&gt; kable(col.names = 'Sampling Method')\n\n\n\n\nSampling Method\n\n\n\n\nagency harvest\n\n\nhunter harvest\n\n\nlive bird\n\n\nmorbidity/mortality\n\n\n\n\n\nOk here lies one of the key assumptions I am going to make about this dataset. Given that the hunter harvested and agency harvested birds were likely out moving/behaving naturally prior to their “removal” I think it is fair to assume that these birds did not exhibit any symptomatic behavior of HPAI. That is also true for the live birds.\nThis is of course opposed to the birds in the “morbidity/mortality” group which likely did exhibit symptoms of HPAI.\nWe are going to want to label the two harvest and live bird methods as “healthy/alive birds” and then the mortality birds as ‘dead’.\n\n#to do that we need to get some indices. \nhunt &lt;- which(d$`Sampling Method`==\"hunter harvest\")\nlive &lt;- which(d$`Sampling Method`==\"live bird\")\nagent &lt;- which(d$`Sampling Method`==\"agency harvest\")\ndead &lt;- which(d$`Sampling Method`=='morbidity/mortality')\n\n#now we just need a status column\nd &lt;- d |&gt; \n  mutate(status=\"NA\")\n\n#now we can just manually change these to what we want. \nd$status[hunt] &lt;- \"alive\"\nd$status[live] &lt;- \"alive\"\nd$status[agent] &lt;- 'alive'\nd$status[dead] &lt;- \"symptomatic\"\n\n#just double check our work.\nlevels(as.factor(x = d$status)) \n\n[1] \"alive\"       \"symptomatic\"\n\n\nOk now we can trim down to the data we would like and do a few edits. I changed the output of this next code chunk to FALSE, but really all I am doing is trimming down to the columns that I want, removing a single case of NA and making the common names lower case.\n\n#ok sweet so lets just trim our data a little\nd &lt;- d |&gt; \n  select(`HPAI Strain`,`Date Detected`,`Bird Species`,status)\n\n# unique(d$`HPAI Strain`) - This shows a single \"NA\"\n\n#' there are alot of different strains but one is NA let's remove that. \nwhich(is.na(d$`HPAI Strain`))\nd &lt;- d[-674,] #remove by negative indexing\n\n### Let's add our species names to this dataset. \nd &lt;- d |&gt; \n  mutate(sci.name=\"NA\",`Bird Species`=tolower(`Bird Species`))\n\nNow we can actually replace the common names with our species name to make a clean and tidy data set. We are going to do that with a four loop that I built to interface with our species lookup sheet.\n\n#lets change some names with my function from the species lookup\n\nfor(i in 1:nrow(d)){ #loops through the rows\n  host &lt;- d$`Bird Species`[i] #finds the host name \n  host\n  if (host %in% Species_Lookup$alt.common.name){ #checks to see if it's in the data\n    y &lt;- which(Species_Lookup$alt.common.name==host) #gets an index\n    y\n    d$sci.name[i] &lt;- Species_Lookup$scientific.name[y] #replaces it with a species\n    d$sci.name[i]\n  }\n}\n\n#unique(d$sci.name) #look for any NA's\n\n#Check to make sure that all the values go through.\nd |&gt; \n  filter(sci.name==\"NA\")\n\n# A tibble: 0 × 5\n# ℹ 5 variables: HPAI Strain &lt;chr&gt;, Date Detected &lt;chr&gt;, Bird Species &lt;chr&gt;,\n#   status &lt;chr&gt;, sci.name &lt;chr&gt;\n\n\nNice it looks like we did not get any NA’s which can sometimes happen if there is a new mispelling of a common name that needs to be added to the lookup file. Here we seem to be good so we can continue.\nWe should note however that some of these ‘species’ names are note real but rather have something like ‘finch spp’ for example. This is because the common name was not identifiable with a true species. Because we are looking at species level data we need to make sure that we only have true species in our dataset so we can remove them.\n\n#' lets remove them by filtering out the string that have \n#' the pattern \" spp\"\nd |&gt; \n  filter(!str_detect(sci.name,pattern = \" spp\")) -&gt; d.clean\n\n# that was alot of work let's save the progress\n#saveRDS(object = d.clean,file = \"data/d.clean_20240328.rds\")\n\nThe final step in our data wrangling is getting our actual trait data. So far all we have done is rearange some columns and fix some names. Lets get some actual data. To do that we are going to make use of the fact that you can group things by species name and then summarise the results. Lets pivot that data into a format where the rows are species rather than observations.\n\nd.trait &lt;- d.clean %&gt;% #get the data\n  group_by(sci.name, status) %&gt;% #group it \n  summarize(n = n()) %&gt;% #count it!\n  pivot_wider(names_from = status, values_from = n, values_fill = 0) #pivot it\n\nhead(d.trait, n=2) |&gt; kable()\n\n\n\n\nsci.name\nsymptomatic\nalive\n\n\n\n\naccipiter cooperii\n31\n0\n\n\naccipiter striatus\n6\n0\n\n\n\n\n\nNow we can calculate mortality and tolerance from this data!\n\nd.trait &lt;- d.trait |&gt; \n  mutate(total_cases=symptomatic+alive) |&gt; \n  mutate(tolerance=alive/total_cases,\nmortality=symptomatic/total_cases)\n\nhead(d.trait,n=5) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\nsci.name\nsymptomatic\nalive\ntotal_cases\ntolerance\nmortality\n\n\n\n\naccipiter cooperii\n31\n0\n31\n0.0000000\n1.0000000\n\n\naccipiter striatus\n6\n0\n6\n0.0000000\n1.0000000\n\n\naechmophorus occidentalis\n1\n0\n1\n0.0000000\n1.0000000\n\n\nagelaius phoeniceus\n1\n0\n1\n0.0000000\n1.0000000\n\n\naix sponsa\n88\n198\n286\n0.6923077\n0.3076923\n\n\n\n\n\nAmazing we now have a datafram that we can begin to ask some questions about. Let’s shift to thinking about the actual phylogenetic tree because having a multiphylo is not the same as having a single tree (its better but thats besides the point).\n\n\n\nOk in because this is a multiphylo we need to make a single maximum clade credibility tree before we do anything further. We can do that easily with the function mcc() in Phangorn.\n\nset.seed(seed = 700) #just a see that I like. \n\n#' I commented the below out for berevity but \n#' you can follow it along to see \n#' what I did.\n\n# mcc.tree &lt;- mcc(x = sample(allbirdtree,size = 100,replace = F),\n#                 tree = T,\n#                 rooted = T)\n# mcc.tree\n\n#saveRDS(object = mcc.tree,file = \"data/mcc.tree.RDS\")\n\nmcc.tree &lt;- readRDS(file = \"data/mcc.tree.RDS\")\n\nAwesome now we have a single tree - a single VERY large tree - that we can now trim to our taxa of interest. This is where those species names come in hand.\n\n#' nice now we have a tree! Unforunately it is way too many tips so we need to prune it. \nmcc.tree$tip.label &lt;- tolower(mcc.tree$tip.label) #just lowering the names case\n\n#pull out the names I want to keep\nnames &lt;- d.trait$sci.name\nnames &lt;- str_replace(string = names,pattern = \" \",replacement = \"_\")\n\n#pruned.mcc.tree &lt;- keep.tip(phy = mcc.tree,tip=names)\n\n#^ you would get an error if you ran keep.tip()\n\nOh noo we get an error! JK, I knew that was going to happen. There is a few problems with some of the scientific names. In reality this is a problem between eBird and BirdTree but I will let it slide for now. We can work around it and fix it. Let’s just get the names we need to fix and then adjust them.\n\n#lets add a BirdTree/Avonet column \nd.trait &lt;- d.trait |&gt; \n  mutate(avonet.name='NA')\n\n#most of the names in sci.name are good but I there are a few to change. Let's do that and also make them lowercase\nd.trait &lt;- d.trait |&gt; \n  group_by(sci.name) |&gt; \n  mutate(avonet.name=str_replace(string = sci.name,pattern = ' ',replacement = '_'))\n\n#' let's see which of my names actually need to change. \nchk.d.trait &lt;- name.check(phy = mcc.tree,data = d.trait,data.names = d.trait$avonet.name)\nsummary(chk.d.trait) #  Notice there are 28 taxa in my data that are not in my tree (yet)\n\n9860 taxa are present in the tree but not the data:\n    abeillia_abeillei,\n    abroscopus_albogularis,\n    abroscopus_schisticeps,\n    abroscopus_superciliaris,\n    aburria_aburri,\n    acanthagenys_rufogularis,\n    ....\n28 taxa are present in the data but not the tree:\n    anser_caerulescens,\n    anser_rossii,\n    antigone_canadensis,\n    ardea_alba,\n    ardenna_tenuirostris,\n    bubo_scandiacus,\n    ....\n\nTo see complete list of mis-matched taxa, print object.\n\n#lets pull out those names to look at, \nnames.to.check &lt;- chk.d.trait$data_not_tree\n#let's also get an indiex for those names to make them NA's \nindex &lt;- which(d.trait$avonet.name%in%names.to.check)\n\n#lets replace these names to fix with NA's\nd.trait$avonet.name[index] &lt;- \"NA\"\n\nOk so we have these names to fix, how are we actually going to fix them. Well I have run into this before on a prior project so I have this other dataset that I am going to load in just so I can steal the “BirdTree/Avonet” names from it.\n\nbv_data &lt;- read.csv(file = \"/Users/jonathandain/My_Files/My_UMB_Courses/BIO634_Phylogenetics/Final_Project/Report/BV_cleaned_12APR2023_v2.csv\")\n\nNow we can replace the names with this dataset just like we did above with the species lookup file. By the way the eBird names of these two datasets match, how do I know that? Because I made it that way haha.\n\n# replace the names with the BV.data\ni=1\nfor(i in 1:nrow(d.trait)){\n  host &lt;- d.trait$sci.name[i]\n  host\n  host &lt;- gsub(x = host,pattern = ' ',replacement = '_')\n  if (host %in% bv_data$species){\n    y &lt;- which(bv_data$species==host)\n    y\n    x &lt;- unique(bv_data$Avonet_name[y])\n    x\n    d.trait$avonet.name[i] &lt;- x\n    # data$sci.name[i]\n  }\n}\n\n#lets see if this worked\nd.trait |&gt; \n  filter(avonet.name==\"NA\") |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nsci.name\nsymptomatic\nalive\ntotal_cases\ntolerance\nmortality\navonet.name\n\n\n\n\nantigone canadensis\n13\n0\n13\n0\n1\nNA\n\n\nardenna tenuirostris\n3\n0\n3\n0\n1\nNA\n\n\ncharadrius nivosus\n5\n0\n5\n0\n1\nNA\n\n\nchroicocephalus philadelphia\n2\n0\n2\n0\n1\nNA\n\n\ncircus hudsonius\n3\n0\n3\n0\n1\nNA\n\n\nhydroprogne caspia\n26\n0\n26\n0\n1\nNA\n\n\nlarus glaucoides thayeri\n1\n0\n1\n0\n1\nNA\n\n\nnannopterum brasilianum\n3\n0\n3\n0\n1\nNA\n\n\nspatula puna\n1\n0\n1\n0\n1\nNA\n\n\nthalasseus maximus\n9\n0\n9\n0\n1\nNA\n\n\nurile penicillatus\n1\n0\n1\n0\n1\nNA\n\n\n\n\n\nOk now it looks like there are just 11 names to fix instead of the 28 that there were before. Thats totally fine we can do that many by hand. We will tackle this by some simple indexing.\n\n#' Ok so just these lat 11 need to be fixed. \n\nwhich(d.trait$sci.name==\"antigone canadensis\")\nd.trait$avonet.name[18] &lt;- \"grus_canadensis\"\n\nwhich(d.trait$sci.name==\"ardenna tenuirostris\")\nd.trait$avonet.name[22] &lt;- \"puffinus_tenuirostris\"\n\nwhich(d.trait$sci.name==\"charadrius nivosus\")\nd.trait$avonet.name[59] &lt;- \"charadrius_alexandrinus\"\n\nwhich(d.trait$sci.name==\"chroicocephalus philadelphia\")\nd.trait$avonet.name[61] &lt;- \"larus_philadelphia\"\n\nwhich(d.trait$sci.name==\"circus hudsonius\")\nd.trait$avonet.name[62] &lt;- \"circus_cyaneus\"\n\nwhich(d.trait$sci.name==\"hydroprogne caspia\")\nd.trait$avonet.name[88] &lt;- \"sterna_caspia\"\n\nwhich(d.trait$sci.name==\"larus glaucoides thayeri\")\nd.trait$avonet.name[95] &lt;- \"larus_thayeri\"\n\nwhich(d.trait$sci.name==\"nannopterum brasilianum\")\nd.trait$avonet.name[113] &lt;- \"phalacrocorax_brasilianus\"\n\nwhich(d.trait$sci.name==\"spatula puna\")\nd.trait$avonet.name[147] &lt;- \"anas_puna\"\n\nwhich(d.trait$sci.name==\"thalasseus maximus\")\nd.trait$avonet.name[154] &lt;- \"sterna_maxima\"\n\nwhich(d.trait$sci.name==\"urile penicillatus\")\nd.trait$avonet.name[160] &lt;- \"phalacrocorax_penicillatus\"\n\nAmazing now we have all the right species names.\nOh I forgot let’s say we wanted to also put in the order and family that these birds come from. We can also do that with our species lookup file. Let’s just do that as well while we are at it. I think it will come in handy later…..\n\nd.trait &lt;- d.trait |&gt; \n  mutate(type=\"NA\",\n         order=\"NA\",\n         family=\"NA\")\n\n#we can use the same four loop function format as above.\nfor(i in 1:nrow(d.trait)){\n  host &lt;- d.trait$sci.name[i]\n  host\n  host &lt;- str_replace(string = host,pattern = \"_\",replacement = \" \")\n  host\n  if (host %in% Species_Lookup$scientific.name){\n    y &lt;- which(Species_Lookup$scientific.name==host)\n    y\n    type &lt;- unique(Species_Lookup$type[y])\n    type\n    d.trait$type[i] &lt;- type\n    fam &lt;-  unique(Species_Lookup$family[y])\n    fam\n    d.trait$family[i] &lt;- fam\n    order &lt;-  unique(Species_Lookup$order[y])\n    order\n    d.trait$order[i] &lt;- order\n    # data$sci.name[i]\n  }\n}\n\n#looks like there was one error with the thayers gull lets fix that!\nwhich(d.trait$avonet.name==\"larus_thayeri\")\nd.trait$order[95] &lt;- 'charadriiformes'\nd.trait$family[95] &lt;- 'laridae (gulls, terns, and skimmers)'\n\n#one more fix sorry. \nwhich(d.trait$family==\"natidae (ducks, geese, and waterfowl)\")\nd.trait$family[32] &lt;- 'anatidae (ducks, geese, and waterfowl)'\n\nAlright few that took a while but now that we have all the names we can actually prune the tree and then get to plotting this yay.\n\nchk.d.trait &lt;- name.check(phy = mcc.tree,\n                          data = d.trait,\n                          data.names = d.trait$avonet.name)\nsummary(chk.d.trait)\n\n9832 taxa are present in the tree but not the data:\n    abeillia_abeillei,\n    abroscopus_albogularis,\n    abroscopus_schisticeps,\n    abroscopus_superciliaris,\n    aburria_aburri,\n    acanthagenys_rufogularis,\n    ....\n\nTo see complete list of mis-matched taxa, print object.\n\n#' ok let's prune the tree finally!\npruned.mcc.tree &lt;- keep.tip(phy = mcc.tree,tip = d.trait$avonet.name)\n\npruned.mcc.tree\n\n\nPhylogenetic tree with 161 tips and 160 internal nodes.\n\nTip labels:\n  dromaius_novaehollandiae, rhea_americana, callipepla_californica, meleagris_gallopavo, bonasa_umbellus, centrocercus_urophasianus, ...\nNode labels:\n  NA, 0.63, 1, 1, 1, 1, ...\n\nRooted; includes branch lengths.\n\n\nLooks like we finally have a tree. The last thing to do is make sure our data and the tree have the same order in terms of rows.\n\n#one final thing let's make sure that it is in the right order\nrow_index &lt;- match(x = pruned.mcc.tree$tip.label,table = d.trait$avonet.name)\nrow_index\nd.trait[row_index,] -&gt; d.trait\n\n#saveRDS(object = d.trait,file = \"data/d.trait.clean_20240328.rds\")\n\n\n\n\nOk so now we can finally plot this thing. First I just want to chat briefly about what we are actually plotting. We are going to be using a function called contMap() from Phytools. What this will be doing is essentially using ancestral state reconstruction across the branches of the tree. We are trying to infer the changes in a continuous trait along the branches of a tree. What this will end up looking like in our case is a color gradient as the value for ‘mortality’ rate changes across the branches of the tree.\nOk with that said - there is alot more to it - lets actually plot this tree.\nIn order to plot this we need to extract our trait of interest into a named vector that we can pass to contMap to make the plot.\n\n\n\n#read in your cleaned data\nd.trait &lt;- readRDS(file = \"data/d.trait.clean_20240328.rds\")\n\n#d.trait |&gt; \n  #mutate(weighted_tol=mortality*total_cases) \n\n#pull the trait\nmortality &lt;- setNames(object =d.trait$mortality,nm = d.trait$avonet.name)\n\n#make the base plot. \nmort_cMap &lt;- contMap(tree = pruned.mcc.tree,x = mortality,plot = T,ftype='off')\n\n\n\n\nYay we have….well we have something. It is not a very good visualization but don’t worry we can make it so much better.\nPlotting for this type of a plot is going to be a really fun exercise in how well you know what is going on internally of a phylogenetic tree. Before we get there though lets mess with the colors a little bit to get a sense of which one we like the best.\nTo do this we are going to use the setMap function to change the color scheme. Then I am going to visualize it without the legend to save space.\n\n#' Lets make four different color schemes. \na &lt;- mort_cMap$cols # the original ones from the above plot\nb &lt;- rev(mort_cMap$cols) # the reverse of those colors. \nc &lt;- grey.colors(n = 30,start = 0) # a greyscale version cause I like that. \nd &lt;- hcl.colors(n = 25,palette = 'Sunset')\ne &lt;- hcl.colors(n = 25,palette = 'Geyser')\nf &lt;- rev(hcl.colors(n = 25,palette = 'Plasma'))\n\n\n#now we can plot them\nmap_a &lt;- setMap(x = mort_cMap,colors=a)\nmap_b &lt;- setMap(x = mort_cMap,colors=b)\nmap_c &lt;- setMap(x = mort_cMap,colors=c)\nmap_d &lt;- setMap(x = mort_cMap,colors=d)\nmap_e &lt;- setMap(x = mort_cMap,colors=e)\nmap_f &lt;- setMap(x = mort_cMap,colors=f)\n\n# now lets plot them. \nM &lt;- matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 2,byrow=T)\nlayout(mat = M)\nplot(map_a,ftype='off',legend=F,outline=F)\nplot(map_b,ftype='off',legend=F,outline=F)\nplot(map_c,ftype='off',legend=F,outline=F)\nplot(map_d,ftype='off',legend=F,outline=F)\nplot(map_e,ftype='off',legend=F,outline=F)\nplot(map_f,ftype='off',legend=F,outline=F)\n\n\n\n\nOk I like the red one, ‘Geyser’ and the ‘Sunset’ one. Lets make those and see what they look like when we add the rest of the bits and bobs.\nOk so to make these presentable we need to do some really “sneaky” plotting of the phylogeny. Its really not all that sneaky but we are going to make use of the phylogenetic tree ‘under the hood’ as they say. We are going to use the internals of the tree to make something that is publication worth and that will serve as one of the intial figures on my dissertation.\n\n\n\nFirst we need to add yet another row to our data set. Just a row to indicate sample size. We want this because this dataset is so sparse we want to know where we can ‘trust’ our analysis and where we might need to be a little skeptical. Adding this additional layer of information onto our tree also means we will need to do a little more sneaky plotting to add it but I will explain as I go. If you would like more details and so I give credit to the author of this hack you can see this blog post by Dr. Liam Revell the author of Phytools.\n\n#add the colum and make a plotting tibble\nplotting &lt;- d.trait |&gt; \n  mutate(size=ifelse(total_cases&gt;=2,'n&gt;2','n&lt;2'))\n\nplotting &lt;- plotting |&gt; \n  mutate(size=as.factor(size)) #just make it a factor\n\nplotting &lt;- as.data.frame(plotting) \n#we make the tibble a dataframe because that is \n#what phytools likes.\n\nOk lets adjust and make this work.\n\nh&lt;-max(nodeHeights(mort_cMap$tree)) #gets the max height of the tree\n\n\nsample.size&lt;-mort_cMap$tree #makes a new tree to edit. \n\nsample.size$edge.length[\n  which(sample.size$edge[,2]&lt;=Ntip(sample.size))]&lt;-\n  sample.size$edge.length[\n    which(sample.size$edge[,2]&lt;=Ntip(sample.size))]+0.07*h\n# ^ The above code piece just extends the tip length of the tree\n\nlevs1&lt;-levels(as.factor(plotting$size)) #pulls factors\n\nsample.size&lt;-paintSubTree(sample.size,Ntip(sample.size)+1,\"t\")\n# ^ This paints the tree transparent.\n\nrownames(plotting) &lt;- plotting$avonet.name \n# ^ This gets the rownames on the data frame\n\nfor(i in 1:nrow(plotting)){\n  tip&lt;-which(mort_cMap$tree$tip.label==\n               rownames(plotting)[i])\n  tip\n  sample.size&lt;-paintSubTree(sample.size,node=tip,\n                         state=levs1[plotting[i,\"size\"]],\n                         stem=(0.05*h)/sample.size$edge.length[\n                           which(sample.size$edge[,2]==tip)])\n}\n# ^ This paints the tips of my tree with\n# the color of the sample size. \n\ncols1&lt;-setNames(c(\"transparent\",\"black\",\"grey\"),\n                c(\"t\",levs1))\n# ^ This just colors the tips, and body of the tree\n\nOk that all looks rather convoluted and complex but it boils down to we basically added some length to the tips of our tree and then painted those tips based on the discrete character that we wanted to. In our case we make them grey if they have low sample size and black of they have a better sample size.\nOk so not to actually plot this the way we want with the sample size and all the fun colors we need to do one key thing. Plot the tree without plotting it. Yup we need to get the size of the space that the tree takes up with these new longer tips and then plot another tree on top of it.\n\n#plot to get x and y lims of the space. \nplot(mort_cMap,type=\"arc\",ftype=\"i\",arc_height=0.5*1.05,add=TRUE,lwd=3,fsize=0.6,offset=10)\npp&lt;-get(\"last_plot.phylo\",envir=.PlotPhyloEnv)\n# ^ this pulls those limits\ngarbage &lt;- dev.off()\n# ^this removes the plot made. \n\n\n#plot for real\nmort_cMap &lt;- setMap(mort_cMap,colors=c)\n# plot base tree first\n\n# note without labels\npar(lend=3)\nplot(mort_cMap,type=\"arc\",\n     ftype=\"off\",\n     arc_height=0.5*1.05,\n     add=TRUE,\n     lwd=3,\n     fsize=0.6,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     legend=F)\n\n# now plot the labels and sample size. \nplot(sample.size,\n     cols1,\n     type=\"arc\",\n     arc_height=0.5*1.05,\n     ftype=\"i\",\n     lwd=5,\n     fsize=0.6,\n     add=T,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     offset=15)\n\n\n\n\nWow that looks so much better but what if we wanted to add some clade labels and a legend for the black and white, oh and a color bar. Well that is easy enough. Let’s grab out clade labels first.\n\n### add some clade labels. \nans_node &lt;- getMRCA(phy = mort_cMap$tree,tip = d.trait[d.trait$order==\"anseriformes\",]$avonet.name)\n#ans_node\n\n#get the node for all charadriiformes\nchar_node &lt;- getMRCA(phy = mort_cMap$tree,tip = d.trait[d.trait$order==\"charadriiformes\",]$avonet.name)\n#char_node\n\nclade_nodes &lt;- tibble(group=c('anseriformes','charadriiformes'),node=c(ans_node,char_node))\n\n\n# arc.cladelabels(tree = pruned.mcc.tree,\"Anseriformes\",node = clade_nodes$node[1],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F,xlim=pp$x.lim,ylim=pp$y.lim)\n# \n# arc.cladelabels(tree = pruned.mcc.tree,\"Charadriiformes\",node = clade_nodes$node[2],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F)\n\nLet’s plot it once again but add in the clade labels and the legends.\n\n#plot for real\nmort_cMap &lt;- setMap(mort_cMap,colors=f)\n# plot base tree first\n\n# note without labels\npar(lend=3,bg=\"white\",mar=c(0.1,0.1,0.1,0.1))\nplot(mort_cMap,type=\"arc\",\n     ftype=\"off\",\n     arc_height=0.5*1.05,\n     add=TRUE,\n     lwd=4,\n     fsize=0.6,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,legend=F,outline=T)\n\n# now plot the labels and sample size. \nplot(sample.size,\n     cols1,\n     type=\"arc\",\n     arc_height=0.5*1.05,\n     ftype=\"i\",\n     lwd=5,\n     fsize=0.6,\n     add=T,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     offset=15)\n\n# add clade labels\narc.cladelabels(tree = pruned.mcc.tree,\"Anseriformes\",node = clade_nodes$node[1],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F,xlim=pp$x.lim,ylim=pp$y.lim)\n\narc.cladelabels(tree = pruned.mcc.tree,\"Charadriiformes\",node = clade_nodes$node[2],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F)\n\n# add legend\nlegend(\"topleft\",levs1,lwd=6,col=cols1[2:3],\n       title=\"Sample Size\")\n\n# add color bar.\nadd.color.bar(leg=118,cols=mort_cMap$cols,title = \"Mortality Rate due to HPAI\",\n              lims = mort_cMap$lims,digits=3,fsize=0.6,x=-80,y=0,prompt = F)\n\n\n\n\nWhat if we wanted to know the amount of phylogenetic signal that might be occuring here. We can do that with phylosig() using two different methods; Blomberg’s K and Pagel’s Lambda\n\n# dev.off() -&gt; garbage\nphylosig(tree = mort_cMap$tree,x = mortality,test = T,method = 'K')\n\n\nPhylogenetic signal K : 0.15881 \nP-value (based on 1000 randomizations) : 0.003 \n\nphylosig(tree = mort_cMap$tree,x = mortality,test = T,method = 'K') |&gt; plot()\n\n\n\n\n\nphylosig(tree = mort_cMap$tree, x=mortality,test = T,method = \"lambda\")\n\n\nPhylogenetic signal lambda : 0.604644 \nlogL(lambda) : 3.44939 \nLR(lambda=0) : 53.1951 \nP-value (based on LR test) : 3.02009e-13 \n\nphylosig(tree = mort_cMap$tree, x=mortality,test = T,method = \"lambda\") |&gt; plot()\n\n\n\n\nThe Blomberg’s K suggests that while the actual value of K is small it is larger than what is expected under a null distribution given a tree of our configuration. We typically see this when you have rapid diversification or the trait is restricted to a single clade in the tree."
  },
  {
    "objectID": "Blog_Posts/2024-04-30/2024-04-30.html#wild-bird-mortality-and-highly-pathogenic-avian-influenza",
    "href": "Blog_Posts/2024-04-30/2024-04-30.html#wild-bird-mortality-and-highly-pathogenic-avian-influenza",
    "title": "Mortality to HPAI and Trees",
    "section": "",
    "text": "A ‘short’ R script by Jonathan Dain.\nGoal: We want to understand the mortality rates in while birds due to HPAI and how it relates to the underlying phylogeny that connects bird species. So let’s dive in.\n\n\n\npacman::p_load(phytools,\n               ggplot2,\n               ggthemes,\n               tidyverse,\n               geiger,\n               knitr,\n               phangorn,\n               rethinking)\n\n\n\n\nOur data comes from multiple sources so I will load each one and give a brief overview of each. To start we need to get our raw data about mortality in wild birds due to HPAI. This data come from the USDA website. It is a collection of observations of HPAI in wild birds. Admittedly this is a very sparse dataset and I know that alot of their observations are oppourtunistic rather than focused searching….but its what we got so lets put it to work.\n\nraw_usda &lt;- read_csv(file = \"data/hpai-wild-birds (1).csv\")\n\nhead(raw_usda) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nState\nCounty\nCollection Date\nDate Detected\nHPAI Strain\nBird Species\nWOAH Classification\nSampling Method\nSubmitting Agency\n\n\n\n\nSouth Carolina\nColleton\n12/30/2021\n01/13/2022\nEA H5N1\nAmerican wigeon\nWild bird\nHunter harvest\nNWDP\n\n\nSouth Carolina\nColleton\n12/30/2021\n01/13/2022\nEA H5N1\nBlue-winged teal\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n12/30/2021\n01/12/2022\nEA H5N1\nNorthern shoveler\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5N1\nAmerican wigeon\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5\nGadwall\nWild bird\nHunter harvest\nNWDP\n\n\nNorth Carolina\nHyde\n01/08/2022\n01/20/2022\nEA H5\nGadwall\nWild bird\nHunter harvest\nNWDP\n\n\n\n\n\nOk the other dataset that we will need is a species lookup file that I have made for replacing common names with species names. It takes as input a common name - often poorly spelled - and replaces it with the correctly spelled latin name. It can also add in some other useful bits which we will look at later.\n\nSpecies_Lookup &lt;- readRDS(file = \"/Users/jonathandain/My_Files/My_Code/Species_Lookup_Sheet/Species_Lookup_20240323.rds\")\n\nhead(Species_Lookup) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\nalt.common.name\ntype\nscientific.name\nenlish.name.ebird\norder\nfamily\n\n\n\n\nafrican crowned crane\nOther\nbalearica regulorum\ngray crowned-crane\ngruiformes\ngruidae (cranes)\n\n\namerican black duck\nDabbling duck\nanas rubripes\namerican black duck\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\namerican blue-winged teal\nDabbling duck\nspatula discors\nblue-winged teal\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\namerican coot\nOther\nfulica americana\namerican coot\ngruiformes\nrallidae (rails, gallinules, and coots)\n\n\namerican crow\nOther\ncorvus brachyrhynchos\namerican crow\npasseriformes\ncorvidae (crows, jays, and magpies)\n\n\namerican green-winged teal\nDabbling duck\nanas crecca\ngreen-winged teal\nanseriformes\nanatidae (ducks, geese, and waterfowl)\n\n\n\n\n\nFinally as you might be wondering we need a bird phylogenetic tree! Thankfully the hard work of actually producing a bird tree has been done for us by the lovely people at BirdTree, we just get to reap the benefits.\n\nallbirdtree &lt;- readRDS(file = \"data/allbirdtree.rds\")\n#note this is a massive multiphylo object so it may take a smidge of time to load.\n\nOk now that our data is loaded we can move onto some data wrangling. Which is the second most fun part of any research question.\n\n\n\nOk first we need to do some data wrangling to make this USDA data usable.let’s first deal with the getting a sense of the data and if these birds are alive or dead when sampled. In other words what is the disease phenotype.\n\n### make a copy of the data\nd &lt;- raw_usda |&gt; \n  mutate_all(.funs = tolower) #make the names lowercase\n\n### look at the sampling methods as levels\nlevels(as.factor(x = d$`Sampling Method`)) |&gt; kable(col.names = 'Sampling Method')\n\n\n\n\nSampling Method\n\n\n\n\nagency harvest\n\n\nhunter harvest\n\n\nlive bird\n\n\nmorbidity/mortality\n\n\n\n\n\nOk here lies one of the key assumptions I am going to make about this dataset. Given that the hunter harvested and agency harvested birds were likely out moving/behaving naturally prior to their “removal” I think it is fair to assume that these birds did not exhibit any symptomatic behavior of HPAI. That is also true for the live birds.\nThis is of course opposed to the birds in the “morbidity/mortality” group which likely did exhibit symptoms of HPAI.\nWe are going to want to label the two harvest and live bird methods as “healthy/alive birds” and then the mortality birds as ‘dead’.\n\n#to do that we need to get some indices. \nhunt &lt;- which(d$`Sampling Method`==\"hunter harvest\")\nlive &lt;- which(d$`Sampling Method`==\"live bird\")\nagent &lt;- which(d$`Sampling Method`==\"agency harvest\")\ndead &lt;- which(d$`Sampling Method`=='morbidity/mortality')\n\n#now we just need a status column\nd &lt;- d |&gt; \n  mutate(status=\"NA\")\n\n#now we can just manually change these to what we want. \nd$status[hunt] &lt;- \"alive\"\nd$status[live] &lt;- \"alive\"\nd$status[agent] &lt;- 'alive'\nd$status[dead] &lt;- \"symptomatic\"\n\n#just double check our work.\nlevels(as.factor(x = d$status)) \n\n[1] \"alive\"       \"symptomatic\"\n\n\nOk now we can trim down to the data we would like and do a few edits. I changed the output of this next code chunk to FALSE, but really all I am doing is trimming down to the columns that I want, removing a single case of NA and making the common names lower case.\n\n#ok sweet so lets just trim our data a little\nd &lt;- d |&gt; \n  select(`HPAI Strain`,`Date Detected`,`Bird Species`,status)\n\n# unique(d$`HPAI Strain`) - This shows a single \"NA\"\n\n#' there are alot of different strains but one is NA let's remove that. \nwhich(is.na(d$`HPAI Strain`))\nd &lt;- d[-674,] #remove by negative indexing\n\n### Let's add our species names to this dataset. \nd &lt;- d |&gt; \n  mutate(sci.name=\"NA\",`Bird Species`=tolower(`Bird Species`))\n\nNow we can actually replace the common names with our species name to make a clean and tidy data set. We are going to do that with a four loop that I built to interface with our species lookup sheet.\n\n#lets change some names with my function from the species lookup\n\nfor(i in 1:nrow(d)){ #loops through the rows\n  host &lt;- d$`Bird Species`[i] #finds the host name \n  host\n  if (host %in% Species_Lookup$alt.common.name){ #checks to see if it's in the data\n    y &lt;- which(Species_Lookup$alt.common.name==host) #gets an index\n    y\n    d$sci.name[i] &lt;- Species_Lookup$scientific.name[y] #replaces it with a species\n    d$sci.name[i]\n  }\n}\n\n#unique(d$sci.name) #look for any NA's\n\n#Check to make sure that all the values go through.\nd |&gt; \n  filter(sci.name==\"NA\")\n\n# A tibble: 0 × 5\n# ℹ 5 variables: HPAI Strain &lt;chr&gt;, Date Detected &lt;chr&gt;, Bird Species &lt;chr&gt;,\n#   status &lt;chr&gt;, sci.name &lt;chr&gt;\n\n\nNice it looks like we did not get any NA’s which can sometimes happen if there is a new mispelling of a common name that needs to be added to the lookup file. Here we seem to be good so we can continue.\nWe should note however that some of these ‘species’ names are note real but rather have something like ‘finch spp’ for example. This is because the common name was not identifiable with a true species. Because we are looking at species level data we need to make sure that we only have true species in our dataset so we can remove them.\n\n#' lets remove them by filtering out the string that have \n#' the pattern \" spp\"\nd |&gt; \n  filter(!str_detect(sci.name,pattern = \" spp\")) -&gt; d.clean\n\n# that was alot of work let's save the progress\n#saveRDS(object = d.clean,file = \"data/d.clean_20240328.rds\")\n\nThe final step in our data wrangling is getting our actual trait data. So far all we have done is rearange some columns and fix some names. Lets get some actual data. To do that we are going to make use of the fact that you can group things by species name and then summarise the results. Lets pivot that data into a format where the rows are species rather than observations.\n\nd.trait &lt;- d.clean %&gt;% #get the data\n  group_by(sci.name, status) %&gt;% #group it \n  summarize(n = n()) %&gt;% #count it!\n  pivot_wider(names_from = status, values_from = n, values_fill = 0) #pivot it\n\nhead(d.trait, n=2) |&gt; kable()\n\n\n\n\nsci.name\nsymptomatic\nalive\n\n\n\n\naccipiter cooperii\n31\n0\n\n\naccipiter striatus\n6\n0\n\n\n\n\n\nNow we can calculate mortality and tolerance from this data!\n\nd.trait &lt;- d.trait |&gt; \n  mutate(total_cases=symptomatic+alive) |&gt; \n  mutate(tolerance=alive/total_cases,\nmortality=symptomatic/total_cases)\n\nhead(d.trait,n=5) |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\nsci.name\nsymptomatic\nalive\ntotal_cases\ntolerance\nmortality\n\n\n\n\naccipiter cooperii\n31\n0\n31\n0.0000000\n1.0000000\n\n\naccipiter striatus\n6\n0\n6\n0.0000000\n1.0000000\n\n\naechmophorus occidentalis\n1\n0\n1\n0.0000000\n1.0000000\n\n\nagelaius phoeniceus\n1\n0\n1\n0.0000000\n1.0000000\n\n\naix sponsa\n88\n198\n286\n0.6923077\n0.3076923\n\n\n\n\n\nAmazing we now have a datafram that we can begin to ask some questions about. Let’s shift to thinking about the actual phylogenetic tree because having a multiphylo is not the same as having a single tree (its better but thats besides the point).\n\n\n\nOk in because this is a multiphylo we need to make a single maximum clade credibility tree before we do anything further. We can do that easily with the function mcc() in Phangorn.\n\nset.seed(seed = 700) #just a see that I like. \n\n#' I commented the below out for berevity but \n#' you can follow it along to see \n#' what I did.\n\n# mcc.tree &lt;- mcc(x = sample(allbirdtree,size = 100,replace = F),\n#                 tree = T,\n#                 rooted = T)\n# mcc.tree\n\n#saveRDS(object = mcc.tree,file = \"data/mcc.tree.RDS\")\n\nmcc.tree &lt;- readRDS(file = \"data/mcc.tree.RDS\")\n\nAwesome now we have a single tree - a single VERY large tree - that we can now trim to our taxa of interest. This is where those species names come in hand.\n\n#' nice now we have a tree! Unforunately it is way too many tips so we need to prune it. \nmcc.tree$tip.label &lt;- tolower(mcc.tree$tip.label) #just lowering the names case\n\n#pull out the names I want to keep\nnames &lt;- d.trait$sci.name\nnames &lt;- str_replace(string = names,pattern = \" \",replacement = \"_\")\n\n#pruned.mcc.tree &lt;- keep.tip(phy = mcc.tree,tip=names)\n\n#^ you would get an error if you ran keep.tip()\n\nOh noo we get an error! JK, I knew that was going to happen. There is a few problems with some of the scientific names. In reality this is a problem between eBird and BirdTree but I will let it slide for now. We can work around it and fix it. Let’s just get the names we need to fix and then adjust them.\n\n#lets add a BirdTree/Avonet column \nd.trait &lt;- d.trait |&gt; \n  mutate(avonet.name='NA')\n\n#most of the names in sci.name are good but I there are a few to change. Let's do that and also make them lowercase\nd.trait &lt;- d.trait |&gt; \n  group_by(sci.name) |&gt; \n  mutate(avonet.name=str_replace(string = sci.name,pattern = ' ',replacement = '_'))\n\n#' let's see which of my names actually need to change. \nchk.d.trait &lt;- name.check(phy = mcc.tree,data = d.trait,data.names = d.trait$avonet.name)\nsummary(chk.d.trait) #  Notice there are 28 taxa in my data that are not in my tree (yet)\n\n9860 taxa are present in the tree but not the data:\n    abeillia_abeillei,\n    abroscopus_albogularis,\n    abroscopus_schisticeps,\n    abroscopus_superciliaris,\n    aburria_aburri,\n    acanthagenys_rufogularis,\n    ....\n28 taxa are present in the data but not the tree:\n    anser_caerulescens,\n    anser_rossii,\n    antigone_canadensis,\n    ardea_alba,\n    ardenna_tenuirostris,\n    bubo_scandiacus,\n    ....\n\nTo see complete list of mis-matched taxa, print object.\n\n#lets pull out those names to look at, \nnames.to.check &lt;- chk.d.trait$data_not_tree\n#let's also get an indiex for those names to make them NA's \nindex &lt;- which(d.trait$avonet.name%in%names.to.check)\n\n#lets replace these names to fix with NA's\nd.trait$avonet.name[index] &lt;- \"NA\"\n\nOk so we have these names to fix, how are we actually going to fix them. Well I have run into this before on a prior project so I have this other dataset that I am going to load in just so I can steal the “BirdTree/Avonet” names from it.\n\nbv_data &lt;- read.csv(file = \"/Users/jonathandain/My_Files/My_UMB_Courses/BIO634_Phylogenetics/Final_Project/Report/BV_cleaned_12APR2023_v2.csv\")\n\nNow we can replace the names with this dataset just like we did above with the species lookup file. By the way the eBird names of these two datasets match, how do I know that? Because I made it that way haha.\n\n# replace the names with the BV.data\ni=1\nfor(i in 1:nrow(d.trait)){\n  host &lt;- d.trait$sci.name[i]\n  host\n  host &lt;- gsub(x = host,pattern = ' ',replacement = '_')\n  if (host %in% bv_data$species){\n    y &lt;- which(bv_data$species==host)\n    y\n    x &lt;- unique(bv_data$Avonet_name[y])\n    x\n    d.trait$avonet.name[i] &lt;- x\n    # data$sci.name[i]\n  }\n}\n\n#lets see if this worked\nd.trait |&gt; \n  filter(avonet.name==\"NA\") |&gt; kable()\n\n\n\n\n\n\n\n\n\n\n\n\n\nsci.name\nsymptomatic\nalive\ntotal_cases\ntolerance\nmortality\navonet.name\n\n\n\n\nantigone canadensis\n13\n0\n13\n0\n1\nNA\n\n\nardenna tenuirostris\n3\n0\n3\n0\n1\nNA\n\n\ncharadrius nivosus\n5\n0\n5\n0\n1\nNA\n\n\nchroicocephalus philadelphia\n2\n0\n2\n0\n1\nNA\n\n\ncircus hudsonius\n3\n0\n3\n0\n1\nNA\n\n\nhydroprogne caspia\n26\n0\n26\n0\n1\nNA\n\n\nlarus glaucoides thayeri\n1\n0\n1\n0\n1\nNA\n\n\nnannopterum brasilianum\n3\n0\n3\n0\n1\nNA\n\n\nspatula puna\n1\n0\n1\n0\n1\nNA\n\n\nthalasseus maximus\n9\n0\n9\n0\n1\nNA\n\n\nurile penicillatus\n1\n0\n1\n0\n1\nNA\n\n\n\n\n\nOk now it looks like there are just 11 names to fix instead of the 28 that there were before. Thats totally fine we can do that many by hand. We will tackle this by some simple indexing.\n\n#' Ok so just these lat 11 need to be fixed. \n\nwhich(d.trait$sci.name==\"antigone canadensis\")\nd.trait$avonet.name[18] &lt;- \"grus_canadensis\"\n\nwhich(d.trait$sci.name==\"ardenna tenuirostris\")\nd.trait$avonet.name[22] &lt;- \"puffinus_tenuirostris\"\n\nwhich(d.trait$sci.name==\"charadrius nivosus\")\nd.trait$avonet.name[59] &lt;- \"charadrius_alexandrinus\"\n\nwhich(d.trait$sci.name==\"chroicocephalus philadelphia\")\nd.trait$avonet.name[61] &lt;- \"larus_philadelphia\"\n\nwhich(d.trait$sci.name==\"circus hudsonius\")\nd.trait$avonet.name[62] &lt;- \"circus_cyaneus\"\n\nwhich(d.trait$sci.name==\"hydroprogne caspia\")\nd.trait$avonet.name[88] &lt;- \"sterna_caspia\"\n\nwhich(d.trait$sci.name==\"larus glaucoides thayeri\")\nd.trait$avonet.name[95] &lt;- \"larus_thayeri\"\n\nwhich(d.trait$sci.name==\"nannopterum brasilianum\")\nd.trait$avonet.name[113] &lt;- \"phalacrocorax_brasilianus\"\n\nwhich(d.trait$sci.name==\"spatula puna\")\nd.trait$avonet.name[147] &lt;- \"anas_puna\"\n\nwhich(d.trait$sci.name==\"thalasseus maximus\")\nd.trait$avonet.name[154] &lt;- \"sterna_maxima\"\n\nwhich(d.trait$sci.name==\"urile penicillatus\")\nd.trait$avonet.name[160] &lt;- \"phalacrocorax_penicillatus\"\n\nAmazing now we have all the right species names.\nOh I forgot let’s say we wanted to also put in the order and family that these birds come from. We can also do that with our species lookup file. Let’s just do that as well while we are at it. I think it will come in handy later…..\n\nd.trait &lt;- d.trait |&gt; \n  mutate(type=\"NA\",\n         order=\"NA\",\n         family=\"NA\")\n\n#we can use the same four loop function format as above.\nfor(i in 1:nrow(d.trait)){\n  host &lt;- d.trait$sci.name[i]\n  host\n  host &lt;- str_replace(string = host,pattern = \"_\",replacement = \" \")\n  host\n  if (host %in% Species_Lookup$scientific.name){\n    y &lt;- which(Species_Lookup$scientific.name==host)\n    y\n    type &lt;- unique(Species_Lookup$type[y])\n    type\n    d.trait$type[i] &lt;- type\n    fam &lt;-  unique(Species_Lookup$family[y])\n    fam\n    d.trait$family[i] &lt;- fam\n    order &lt;-  unique(Species_Lookup$order[y])\n    order\n    d.trait$order[i] &lt;- order\n    # data$sci.name[i]\n  }\n}\n\n#looks like there was one error with the thayers gull lets fix that!\nwhich(d.trait$avonet.name==\"larus_thayeri\")\nd.trait$order[95] &lt;- 'charadriiformes'\nd.trait$family[95] &lt;- 'laridae (gulls, terns, and skimmers)'\n\n#one more fix sorry. \nwhich(d.trait$family==\"natidae (ducks, geese, and waterfowl)\")\nd.trait$family[32] &lt;- 'anatidae (ducks, geese, and waterfowl)'\n\nAlright few that took a while but now that we have all the names we can actually prune the tree and then get to plotting this yay.\n\nchk.d.trait &lt;- name.check(phy = mcc.tree,\n                          data = d.trait,\n                          data.names = d.trait$avonet.name)\nsummary(chk.d.trait)\n\n9832 taxa are present in the tree but not the data:\n    abeillia_abeillei,\n    abroscopus_albogularis,\n    abroscopus_schisticeps,\n    abroscopus_superciliaris,\n    aburria_aburri,\n    acanthagenys_rufogularis,\n    ....\n\nTo see complete list of mis-matched taxa, print object.\n\n#' ok let's prune the tree finally!\npruned.mcc.tree &lt;- keep.tip(phy = mcc.tree,tip = d.trait$avonet.name)\n\npruned.mcc.tree\n\n\nPhylogenetic tree with 161 tips and 160 internal nodes.\n\nTip labels:\n  dromaius_novaehollandiae, rhea_americana, callipepla_californica, meleagris_gallopavo, bonasa_umbellus, centrocercus_urophasianus, ...\nNode labels:\n  NA, 0.63, 1, 1, 1, 1, ...\n\nRooted; includes branch lengths.\n\n\nLooks like we finally have a tree. The last thing to do is make sure our data and the tree have the same order in terms of rows.\n\n#one final thing let's make sure that it is in the right order\nrow_index &lt;- match(x = pruned.mcc.tree$tip.label,table = d.trait$avonet.name)\nrow_index\nd.trait[row_index,] -&gt; d.trait\n\n#saveRDS(object = d.trait,file = \"data/d.trait.clean_20240328.rds\")\n\n\n\n\nOk so now we can finally plot this thing. First I just want to chat briefly about what we are actually plotting. We are going to be using a function called contMap() from Phytools. What this will be doing is essentially using ancestral state reconstruction across the branches of the tree. We are trying to infer the changes in a continuous trait along the branches of a tree. What this will end up looking like in our case is a color gradient as the value for ‘mortality’ rate changes across the branches of the tree.\nOk with that said - there is alot more to it - lets actually plot this tree.\nIn order to plot this we need to extract our trait of interest into a named vector that we can pass to contMap to make the plot.\n\n\n\n#read in your cleaned data\nd.trait &lt;- readRDS(file = \"data/d.trait.clean_20240328.rds\")\n\n#d.trait |&gt; \n  #mutate(weighted_tol=mortality*total_cases) \n\n#pull the trait\nmortality &lt;- setNames(object =d.trait$mortality,nm = d.trait$avonet.name)\n\n#make the base plot. \nmort_cMap &lt;- contMap(tree = pruned.mcc.tree,x = mortality,plot = T,ftype='off')\n\n\n\n\nYay we have….well we have something. It is not a very good visualization but don’t worry we can make it so much better.\nPlotting for this type of a plot is going to be a really fun exercise in how well you know what is going on internally of a phylogenetic tree. Before we get there though lets mess with the colors a little bit to get a sense of which one we like the best.\nTo do this we are going to use the setMap function to change the color scheme. Then I am going to visualize it without the legend to save space.\n\n#' Lets make four different color schemes. \na &lt;- mort_cMap$cols # the original ones from the above plot\nb &lt;- rev(mort_cMap$cols) # the reverse of those colors. \nc &lt;- grey.colors(n = 30,start = 0) # a greyscale version cause I like that. \nd &lt;- hcl.colors(n = 25,palette = 'Sunset')\ne &lt;- hcl.colors(n = 25,palette = 'Geyser')\nf &lt;- rev(hcl.colors(n = 25,palette = 'Plasma'))\n\n\n#now we can plot them\nmap_a &lt;- setMap(x = mort_cMap,colors=a)\nmap_b &lt;- setMap(x = mort_cMap,colors=b)\nmap_c &lt;- setMap(x = mort_cMap,colors=c)\nmap_d &lt;- setMap(x = mort_cMap,colors=d)\nmap_e &lt;- setMap(x = mort_cMap,colors=e)\nmap_f &lt;- setMap(x = mort_cMap,colors=f)\n\n# now lets plot them. \nM &lt;- matrix(c(1,2,3,4,5,6),nrow = 3,ncol = 2,byrow=T)\nlayout(mat = M)\nplot(map_a,ftype='off',legend=F,outline=F)\nplot(map_b,ftype='off',legend=F,outline=F)\nplot(map_c,ftype='off',legend=F,outline=F)\nplot(map_d,ftype='off',legend=F,outline=F)\nplot(map_e,ftype='off',legend=F,outline=F)\nplot(map_f,ftype='off',legend=F,outline=F)\n\n\n\n\nOk I like the red one, ‘Geyser’ and the ‘Sunset’ one. Lets make those and see what they look like when we add the rest of the bits and bobs.\nOk so to make these presentable we need to do some really “sneaky” plotting of the phylogeny. Its really not all that sneaky but we are going to make use of the phylogenetic tree ‘under the hood’ as they say. We are going to use the internals of the tree to make something that is publication worth and that will serve as one of the intial figures on my dissertation.\n\n\n\nFirst we need to add yet another row to our data set. Just a row to indicate sample size. We want this because this dataset is so sparse we want to know where we can ‘trust’ our analysis and where we might need to be a little skeptical. Adding this additional layer of information onto our tree also means we will need to do a little more sneaky plotting to add it but I will explain as I go. If you would like more details and so I give credit to the author of this hack you can see this blog post by Dr. Liam Revell the author of Phytools.\n\n#add the colum and make a plotting tibble\nplotting &lt;- d.trait |&gt; \n  mutate(size=ifelse(total_cases&gt;=2,'n&gt;2','n&lt;2'))\n\nplotting &lt;- plotting |&gt; \n  mutate(size=as.factor(size)) #just make it a factor\n\nplotting &lt;- as.data.frame(plotting) \n#we make the tibble a dataframe because that is \n#what phytools likes.\n\nOk lets adjust and make this work.\n\nh&lt;-max(nodeHeights(mort_cMap$tree)) #gets the max height of the tree\n\n\nsample.size&lt;-mort_cMap$tree #makes a new tree to edit. \n\nsample.size$edge.length[\n  which(sample.size$edge[,2]&lt;=Ntip(sample.size))]&lt;-\n  sample.size$edge.length[\n    which(sample.size$edge[,2]&lt;=Ntip(sample.size))]+0.07*h\n# ^ The above code piece just extends the tip length of the tree\n\nlevs1&lt;-levels(as.factor(plotting$size)) #pulls factors\n\nsample.size&lt;-paintSubTree(sample.size,Ntip(sample.size)+1,\"t\")\n# ^ This paints the tree transparent.\n\nrownames(plotting) &lt;- plotting$avonet.name \n# ^ This gets the rownames on the data frame\n\nfor(i in 1:nrow(plotting)){\n  tip&lt;-which(mort_cMap$tree$tip.label==\n               rownames(plotting)[i])\n  tip\n  sample.size&lt;-paintSubTree(sample.size,node=tip,\n                         state=levs1[plotting[i,\"size\"]],\n                         stem=(0.05*h)/sample.size$edge.length[\n                           which(sample.size$edge[,2]==tip)])\n}\n# ^ This paints the tips of my tree with\n# the color of the sample size. \n\ncols1&lt;-setNames(c(\"transparent\",\"black\",\"grey\"),\n                c(\"t\",levs1))\n# ^ This just colors the tips, and body of the tree\n\nOk that all looks rather convoluted and complex but it boils down to we basically added some length to the tips of our tree and then painted those tips based on the discrete character that we wanted to. In our case we make them grey if they have low sample size and black of they have a better sample size.\nOk so not to actually plot this the way we want with the sample size and all the fun colors we need to do one key thing. Plot the tree without plotting it. Yup we need to get the size of the space that the tree takes up with these new longer tips and then plot another tree on top of it.\n\n#plot to get x and y lims of the space. \nplot(mort_cMap,type=\"arc\",ftype=\"i\",arc_height=0.5*1.05,add=TRUE,lwd=3,fsize=0.6,offset=10)\npp&lt;-get(\"last_plot.phylo\",envir=.PlotPhyloEnv)\n# ^ this pulls those limits\ngarbage &lt;- dev.off()\n# ^this removes the plot made. \n\n\n#plot for real\nmort_cMap &lt;- setMap(mort_cMap,colors=c)\n# plot base tree first\n\n# note without labels\npar(lend=3)\nplot(mort_cMap,type=\"arc\",\n     ftype=\"off\",\n     arc_height=0.5*1.05,\n     add=TRUE,\n     lwd=3,\n     fsize=0.6,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     legend=F)\n\n# now plot the labels and sample size. \nplot(sample.size,\n     cols1,\n     type=\"arc\",\n     arc_height=0.5*1.05,\n     ftype=\"i\",\n     lwd=5,\n     fsize=0.6,\n     add=T,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     offset=15)\n\n\n\n\nWow that looks so much better but what if we wanted to add some clade labels and a legend for the black and white, oh and a color bar. Well that is easy enough. Let’s grab out clade labels first.\n\n### add some clade labels. \nans_node &lt;- getMRCA(phy = mort_cMap$tree,tip = d.trait[d.trait$order==\"anseriformes\",]$avonet.name)\n#ans_node\n\n#get the node for all charadriiformes\nchar_node &lt;- getMRCA(phy = mort_cMap$tree,tip = d.trait[d.trait$order==\"charadriiformes\",]$avonet.name)\n#char_node\n\nclade_nodes &lt;- tibble(group=c('anseriformes','charadriiformes'),node=c(ans_node,char_node))\n\n\n# arc.cladelabels(tree = pruned.mcc.tree,\"Anseriformes\",node = clade_nodes$node[1],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F,xlim=pp$x.lim,ylim=pp$y.lim)\n# \n# arc.cladelabels(tree = pruned.mcc.tree,\"Charadriiformes\",node = clade_nodes$node[2],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F)\n\nLet’s plot it once again but add in the clade labels and the legends.\n\n#plot for real\nmort_cMap &lt;- setMap(mort_cMap,colors=f)\n# plot base tree first\n\n# note without labels\npar(lend=3,bg=\"white\",mar=c(0.1,0.1,0.1,0.1))\nplot(mort_cMap,type=\"arc\",\n     ftype=\"off\",\n     arc_height=0.5*1.05,\n     add=TRUE,\n     lwd=4,\n     fsize=0.6,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,legend=F,outline=T)\n\n# now plot the labels and sample size. \nplot(sample.size,\n     cols1,\n     type=\"arc\",\n     arc_height=0.5*1.05,\n     ftype=\"i\",\n     lwd=5,\n     fsize=0.6,\n     add=T,\n     xlim=pp$x.lim,\n     ylim=pp$y.lim,\n     offset=15)\n\n# add clade labels\narc.cladelabels(tree = pruned.mcc.tree,\"Anseriformes\",node = clade_nodes$node[1],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F,xlim=pp$x.lim,ylim=pp$y.lim)\n\narc.cladelabels(tree = pruned.mcc.tree,\"Charadriiformes\",node = clade_nodes$node[2],col=\"black\",lab.offset=1.07,ln.offset=1.04,mark.node=F)\n\n# add legend\nlegend(\"topleft\",levs1,lwd=6,col=cols1[2:3],\n       title=\"Sample Size\")\n\n# add color bar.\nadd.color.bar(leg=118,cols=mort_cMap$cols,title = \"Mortality Rate due to HPAI\",\n              lims = mort_cMap$lims,digits=3,fsize=0.6,x=-80,y=0,prompt = F)\n\n\n\n\nWhat if we wanted to know the amount of phylogenetic signal that might be occuring here. We can do that with phylosig() using two different methods; Blomberg’s K and Pagel’s Lambda\n\n# dev.off() -&gt; garbage\nphylosig(tree = mort_cMap$tree,x = mortality,test = T,method = 'K')\n\n\nPhylogenetic signal K : 0.15881 \nP-value (based on 1000 randomizations) : 0.003 \n\nphylosig(tree = mort_cMap$tree,x = mortality,test = T,method = 'K') |&gt; plot()\n\n\n\n\n\nphylosig(tree = mort_cMap$tree, x=mortality,test = T,method = \"lambda\")\n\n\nPhylogenetic signal lambda : 0.604644 \nlogL(lambda) : 3.44939 \nLR(lambda=0) : 53.1951 \nP-value (based on LR test) : 3.02009e-13 \n\nphylosig(tree = mort_cMap$tree, x=mortality,test = T,method = \"lambda\") |&gt; plot()\n\n\n\n\nThe Blomberg’s K suggests that while the actual value of K is small it is larger than what is expected under a null distribution given a tree of our configuration. We typically see this when you have rapid diversification or the trait is restricted to a single clade in the tree."
  },
  {
    "objectID": "Blog_Posts/2024-04-30/2024-04-30.html#our-final-plot",
    "href": "Blog_Posts/2024-04-30/2024-04-30.html#our-final-plot",
    "title": "Mortality to HPAI and Trees",
    "section": "Our Final Plot:",
    "text": "Our Final Plot:\nFinally lets just plot the final tree one last time to really see it.\n\n\n\nMortality to HPAI Plotted on an Avian Tree\n\n\n\nKey Takeaways:\n\nThe majority of the tree is purple, indicating very high mortality due to HPAI.\n\nThe areas of yellow, indicating low mortality to HPAI are primarily restricted to members of the family ANATIDAE, which include our lovely friends the Mallard and American Black Duck.\n\nWhile the “tolerance” to HPAI is likely to place a species into the “super-spreader” camp given that there are so many taxa that have high mortality there might be other “super-spreaders” that exhibit a vastly different phenotype than being asymptomatic.\n\n\n\nFuture Directions:\n\nTo answer that last point about alternatives to asymptomatic “super-spreaders”, I am planning on performing a bayesian phylodynamic assay to evaluate source/sink dynamics. This will tell me if the taxa that are colored purple are acting as sources “spreaders” or sinks. In short it will tell me if there really is another version of “super-spreader”.\n\nI hope that this script has been as helpful to you as it was to me. As always keep your eyes to the sky!\nCheers, Jonathan Dain"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Yours truly on Appledore Island, where Great Black-Back Gulls and Herring Gulls breed in massive numbers\n\n\nHello there my dear friends and welcome to the world of birds and their viruses\n\nInside the Lab:\nMy name is Jonathan Dain, and I am a Ph.D. student at UMASS Boston working in the VirusPlusLab led by Dr. Nichola Hill. We are a “Disease Ecology” lab focused on answering questions about the recent avian influenza outbreaks in wild birds. My personal interests lie at the intersection of the host virus dynamic. What are the ecological and phylogenetic drivers of avian influenza in the current North American outbreak? What can we learn from the host about infection with this virus in terms of the disease phenotype and immune response? What can we learn from the viral genomes about spread of the virus, host factors affecting spread and much more? Why do some bird species get infected with the virus and die very quickly while others are asymptomatic? How much does the host gene expression impact the spread of this virus into new areas and populations?\n\n\nOutside the Lab:\nApart from my studies at UMB, I am a fun-loving husband to Amanda Dain. I am an avid herpetologist and ornithologist and you will often find me with eyes to the sky, flipping logs, or waist-deep in a bog with frogs. As a lover of coffee, I am always down to pour a cup and sit at the table with a great book or have a deep conversation with a friend. I do my best to find beauty in the little moments in life and I have often said “wonder makes the common uncommon”. So come join me on this adventure with birds, viruses, coffee, and books and let’s see what wonders are ahead of us."
  }
]